 # cpu_simulation.py
 import time
 import numpy as np
 class CPUSimulator:
 """
    Simulate CPU behaviour by converting operation counts into a synthetic 
delay.
    `clock_factor` is relative: higher -> faster CPU (less delay per operation).
    For example: Basic=1.0, Mid=2.0, Pro=5.0
    """
 def __init__(self, name: str, clock_factor: float = 1.0, base_op_cost: float
 = 1e-6):
 self.name = name
 self.clock_factor = clock_factor
 self.base_op_cost = base_op_cost # seconds per operation at factor=1.0
 def simulate(self, func, *args, **kwargs):
 """Runs `func` and returns (result, metrics) where metrics contains 
real_time and simulated_time."""
 start = time.perf_counter()
 result = func(*args, **kwargs)
 end = time.perf_counter()
 real_elapsed = end- start
 # function expected to return (sorted_list, stats)
 try:
 _, stats = result
 except Exception:
 stats = {"comparisons": 0, "swaps": 0}
 op_count = stats.get("comparisons", 0) + stats.get("swaps", 0)
 simulated_delay = op_count * (self.base_op_cost / self.clock_factor)
 simulated_total = real_elapsed + simulated_delay
 metrics = {
 "cpu": self.name,
 "real_time": real_elapsed,
 "simulated_time": simulated_total,
 "op_count": op_count,
 **stats,
 }
 return result, metrics
 4
def run_multiple_times(simulator: CPUSimulator, algorithm_instance,
 data_generator, input_size: int, runs: int = 5):
 """Run `algorithm_instance.sort` multiple times on arrays generated by 
`data_generator`.
    Returns list of simulated_time values and the raw metrics for each run.
    """
 times = []
 raw = []
 for _ in range(runs):
 arr = data_generator(input_size)
 (_, _), metrics = simulator.simulate(algorithm_instance.sort, arr)
 times.append(metrics["simulated_time"])
 raw.append(metrics)
 return np.array(times), raw